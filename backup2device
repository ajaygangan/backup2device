#!/usr/bin/env bash

# Script: backup2device.sh
# Author: Ajay G
# Description: A flexible script to back up the $HOME directory or user-specified directories to an external drive/mtp-device or a local backup directory.

# ERROR HANDLING
set -euo pipefail

# IMPORTANT VARIABLES
# File name of the 'backed-up' archive file
BACKUP_FILE_NAME="$(date +%Y%m%dT%H%M%S)--$(hostname)__$(cat /etc/*-release | grep PRETTY_NAME | cut -d'=' -f2 | tr -d '" ()').tar.gz"

# Directories or files to 'exclude' from $HOME
# Specify only the filename
# eg; (".cache" "Desktop" "Downloads" "Music" "Videos")
EXCLUDE_DIRS=(".cache")

# Directories or files to 'include' other than from $HOME
# Specify the full filename i.e., including the path
# eg; ("/etc" "/usr/local/share")
INCLUDE_DIRS=()

# Options for tar
# -z : use gzip / -J : use xz (Remember to add .gz or .xz to BACKUP_FILE_NAME)
# -p : preserve permissions
# keep -c at the beginning and -f at the end
TAR_OPTIONS="-cvzf"

# DEFINE COLORS
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RESET='\033[0m' # No Color
# WARN
[ -z "$TAR_OPTIONS" ] && echo -e "${RED}Error: TAR_OPTIONS is empty in the script; fatal!${RESET}"
[ ${#EXCLUDE_DIRS[@]} -eq 0 ] && echo "${YELLOW}Warning: EXCLUDE_DIRS is empty in the script; not fatal!${RESET}"
[ "$PWD" != "$HOME" ] && echo -e "${RED}Warning: You are not in your home directory!${RESET}"
DEPENDENCIES=(tar gpg ls lsblk nl read echo mkdir)
for dep in "${DEPENDENCIES[@]}"; do
    command -v "$dep" &> /dev/null || { echo "${RED}Error: $dep is not installed. Please install it to continue.${RESET}"; exit 1; }
done

# Get a list of external drives (excluding internal drives and loop devices)
DRIVES=$(lsblk -d -o NAME,FSTYPE,SIZE,MOUNTPOINT -e 7,1 | awk '$1 ~ /^sd/ && $4 != "/" {print $0}')
# Get a list of gvfs-mtp mounted devices
# TODO; support for other mtp mountpoints;
MTP_DEVICES=$(ls -1t /run/user/$UID/gvfs/)
# Local format
LOCAL="Local $(df -h --output=avail $HOME | sed -n '2p') $HOME"
# Check if any drives or mtp-devices are found
if [ -z "$DRIVES" ]; then
    DRIVES="No External Drives found!"
fi
if [ -z "$MTP_DEVICES" ]; then
    MTP_DEVICES="No MTP-Devices/Phones found!"
fi
# First prompt
# Display drives or mtp-devices in a numbered menu
echo "Where to backup:"
echo -e "$DRIVES\n$MTP_DEVICES\n$LOCAL" | nl -s ') '
read -p "$(echo -e "${BLUE}Choose a Number and Enter: ${RESET}")" choice_num
CHOICE=$(echo -e "$DRIVES\n$MTP_DEVICES\n$LOCAL" | sed -n "${choice_num}p")
# Process the choice
if [ "$DRIVES" != "No External Drives found!" ] && echo "$DRIVES" | grep -q "^$CHOICE$"; then
    echo "Selected: $CHOICE"
    # Get the selected drive's mountpoint
    DRIVE_SEL=$(echo "$CHOICE" | awk '{print $4}')
    # Check if the drive is mounted
    if [ -z "$DRIVE_SEL" ]; then
	echo -e "${RED}Please mount the Drive and try again!${RESET}"
	exit 1
    fi
    # Prompt for confirmation
    read -p "$(echo -e "${BLUE}Proceed with backup on $DRIVE_SEL/Backups ? (y/n): ${RESET}")" confirm
    if [ "$confirm" != "y" ]; then
	read -e -p "$(echo -e "${BLUE}Enter location (start from $DRIVE_SEL): ${RESET}")" confirm_loc
	EXTERNAL_DIR="$confirm_loc"
	read -p "$(echo -e "${BLUE}Proceed with backup to $EXTERNAL_DIR (y/n): ${RESET}")" confirmy
	if [ "$confirmy" != "y" ]; then
	    echo -e "${RED}Backup cancelled.${RESET}"
	    exit 0
	fi
    else
	EXTERNAL_DIR="$DRIVE_SEL/Backups"
    fi
    mkdir -p "$EXTERNAL_DIR"
    DEST="$EXTERNAL_DIR/$BACKUP_FILE_NAME"
elif [ "$MTP_DEVICES" != "No MTP-Devices/Phones found!" ] && echo "$MTP_DEVICES" | grep -q "^$CHOICE$"; then
    echo "Selected: $CHOICE"
    # Get the selected mtp-device's mountpoint
    DEVICE_SEL="/run/user/$UID/gvfs/$(ls -1tb /run/user/$UID/gvfs/)/Internal shared storage"
    read -p "$(echo -e "${BLUE}Proceed with backup on $DEVICE_SEL/Backups ? (y/n): ${RESET}")" confirm
    if [ "$confirm" != "y" ]; then
	read -e -p "$(echo -e "${BLUE}Enter location (start from $DEVICE_SEL): ${RESET}")" confirm_loc
	DEVICE_DIR="$confirm_loc"
	read -p "$(echo -e "${BLUE}Proceed with backup to $DEVICE_DIR (y/n): ${RESET}")" confirmy
	if [ "$confirmy" != "y" ]; then
	    echo -e "${RED}Backup cancelled.${RESET}"
	    exit 0
	fi
    else
	DEVICE_DIR="/run/user/$UID/gvfs/$(ls -1tb /run/user/$UID/gvfs/)/Internal shared storage/Backups"
    fi
    mkdir -p "$DEVICE_DIR"
    DEST="$DEVICE_DIR/$BACKUP_FILE_NAME"
elif [ "$CHOICE" = "$LOCAL" ]; then
    echo "Selected: $CHOICE"
    read -p "$(echo -e "${BLUE}Proceed with backup to ~/Downloads/Backups (y/n): ${RESET}")" confirm
    if [ "$confirm" != "y" ]; then
	read -e -p "$(echo -e "${BLUE}Enter location: ${RESET}")" confirm_loc
	LOCAL_DIR="$confirm_loc"
	read -p "Proceed with backup to $LOCAL_DIR (y/n): " confirmy
	if [ "$confirmy" != "y" ]; then
	    echo -e "${RED}Backup cancelled.${RESET}"
	    exit 0
	fi
    else
	LOCAL_DIR="$HOME/Downloads/Backups"
    fi
    mkdir -p "$LOCAL_DIR"
    EXCLUDE_DIRS+=("$LOCAL_DIR")
    DEST="$LOCAL_DIR/$BACKUP_FILE_NAME"    
else
    echo -e "${RED}Invalid response: ${RESET}$CHOICE"
    exit 1
fi

# Functions for appending dirs mentioned in EXCLUDE_FLAGS and INCLUDE_FLAGS into tar cmd
EXCLUDE_FLAGS=()
for dir in "${EXCLUDE_DIRS[@]}"; do
    EXCLUDE_FLAGS+=("--exclude=$dir")
done
INCLUDE_FLAGS=()
for dir in "${INCLUDE_DIRS[@]}"; do
    INCLUDE_FLAGS+=("$dir")
done
# To write tar archive directly to destination
read -p "$(echo -e "${BLUE}Proceed with backup Encryption (y/n): ${RESET}")" confirm
if [ "$confirm" != "y" ]; then
    MESSAGE="Run '$ tar "${TAR_OPTIONS/c/x}" <backup>.tar.gz' to extract!"
    tar $TAR_OPTIONS "$DEST" "${INCLUDE_FLAGS[@]}" -C "$HOME" "${EXCLUDE_FLAGS[@]}" .
else
    MESSAGE="Run '$ gpg -d <backup>.tar.gz | tar "${TAR_OPTIONS/c/x}" -' to extract!"
    tar $TAR_OPTIONS - "${INCLUDE_FLAGS[@]}" -C "$HOME" "${EXCLUDE_FLAGS[@]}" . | gpg --symmetric -o "$DEST".gpg
fi
#pid=$!
#echo "Press 'C-c' to cancel"
#cancel_fun() {
#    kill $pid 2>/dev/null
#    echo -e "${RED}Backup cancelled.${RESET}"
#    exit 0
#}
#trap cancel_fun SIGINT SIGTERM EXIT
# Display size metrics while process is running
#TOTALSIZE="$(du -sh "${EXCLUDE_FLAGS[@]}" "$HOME")"
#while kill -0 "$pid" 2>/dev/null; do
#    printf '\rBacking up %s - Current archive size %s' "$TOTALSIZE" "$(du -sh $DEST | awk '{print$1}')"
#    sleep 1
#done

# VERIFY
#wait $pid
if [ $? -eq 0 ]; then
    echo -e "${GREEN}Backup successfully created at $DEST${RESET}"
    printf 'Backed up archive size is %s' "$(du -sh $DEST | awk '{print$1}')"
    echo -e "${YELLOW}$MESSAGE${RESET}"
    exit 0
else
    echo -e "${RED}Failed to create backup at $DEST${RESET}"
    exit 1
fi
